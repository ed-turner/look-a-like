<!DOCTYPE html>
<html >
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
      <title>Look-A-Like 0.0.0 documentation</title>
    
      <link rel="stylesheet" href="_static/pygments.css">
      <link rel="stylesheet" href="_static/theme.css">
      
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>

      <!-- sphinx script_files -->
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>

      
      <script src="_static/theme-vendors.js"></script>
      <script src="_static/theme.js" defer></script>
    
  <link rel="index" title="Index" href="genindex.html" />
  <link rel="search" title="Search" href="search.html" /> 
  </head>

  <body><div id="app" class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="index.html#document-index" class="home-link">
    
      <span class="site-name">Look-A-Like</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">

  
    <div class="nav-item">
      <a href="index.html#document-index#welcome-to-look-a-like-s-python-package-documentation"
         class="nav-link ">
         Contents:
      </a>
    </div>
  
    <div class="nav-item">
      <a href="index.html#document-lal#subpackages"
         class="nav-link ">
         lal package
      </a>
    </div>
  



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            

  
    <div class="nav-item">
      <a href="index.html#document-index#welcome-to-look-a-like-s-python-package-documentation"
         class="nav-link ">
         Contents:
      </a>
    </div>
  
    <div class="nav-item">
      <a href="index.html#document-lal#subpackages"
         class="nav-link ">
         lal package
      </a>
    </div>
  



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">Quick search</span>
    <div class="searchformwrapper">
      <form class="search" action="search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="Search" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="index.html#document-index#welcome-to-look-a-like-s-python-package-documentation">Contents:</a></span>
      </p>
      <ul class="">
        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="index.html#document-lal#subpackages">lal package</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 "><a href="index.html#document-lal.core" class="reference internal ">lal.core package</a>

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="index.html#document-index">Docs</a> &raquo;</li>
    
    <li>Look-A-Like 0.0.0 documentation</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main">
            
  <div class="section" id="welcome-to-look-a-like-s-python-package-documentation">
<h1>Welcome to Look-A-Like’s Python-Package documentation!<a class="headerlink" href="#welcome-to-look-a-like-s-python-package-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
</div>
<div class="section" id="software-package-details">
<h1>Software Package Details<a class="headerlink" href="#software-package-details" title="Permalink to this headline">¶</a></h1>
<p>Author: Edward Turner</p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Generally, we want to be able to predict various characteristics,
perhaps simultaneously, ensuring that the samples in the testing
dateset that “looks like” the samples in the training dataset have
similar predictive values.  There are various methods that exist
today that are predictive in nature, and are well documented. However,
there are few that is able to ensure that samples from the testing dataset
with similar features as in the testing dataset have similar predictive values.</p>
<p>This python package delivers a highly sought-after methodology, which utilizes
the relative importance each feature has to be predictive to our chosen value
and scales our features accordingly their importance, then perform a nearest
neighbors algorithm to generate our matches.</p>
<p>A more full description of the methodology is found under the Methodology section.</p>
</div>
<div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>One method of installing the python package, whether in a virtual environment
or your own local machine, is to git clone the repo, change the directory
to the python-package directory, and run <cite>python setup.py install</cite>.</p>
</div>
<div class="section" id="methodology">
<h2>Methodology<a class="headerlink" href="#methodology" title="Permalink to this headline">¶</a></h2>
<p>As mentioned in the introduction, we derive some values that are based on
the predictive power of each feature and scale those features by those values. To
do that, we use the Light Gradient Boosting Method (LGBM) to fit the training dataset.
To optimize the LGBM using bayesian hyper parameter optimize on a train/validation
split on the original training dataset.  Once optimized, we fit on the entire
training dataset. By doing so, we will generate the feature importance for
each feature.  We then scale our feature importance so that they are nonzero
and sum to one.  This is the very first step.</p>
<p>Once we derive our feature importance, we scale our features according to their
feature importance, after standardizing our features.  There are several available
distance measures to use for our matching algorithm, along with different ways
to find our closest neighbors.  For our distance calculation, we have the
p-norm measure and the cosine measure. For our nearest-neighbors algorithm, we
have the k-nearest-neighbors algorithm and the hungarian-matching algorithm.
This gives us a total of 4 types of matching algorithms.</p>
</div>
<div class="section" id="tutorial">
<h2>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h2>
<p>To use this model, simply follow this short example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">lal</span> <span class="kn">import</span> <span class="n">LALGBRegressor</span>

<span class="c1"># to use the linear sum assigment for matches,</span>
<span class="c1"># pass linear_sum to k;</span>
<span class="c1"># and use the cosine measure,</span>
<span class="c1"># pass cosine to the p value</span>
<span class="n">model_params</span> <span class="o">=</span> <span class="p">{</span>
<span class="s2">&quot;k&quot;</span><span class="p">:</span> <span class="s2">&quot;linear_sum&quot;</span><span class="p">,</span>
<span class="s2">&quot;p&quot;</span><span class="p">:</span> <span class="s2">&quot;cosine&quot;</span>
               <span class="p">}</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">LALGBRegressor</span><span class="p">(</span><span class="o">**</span><span class="n">model_params</span><span class="p">)</span>

<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">)</span>

<span class="n">test_labels</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
                        <span class="n">train_data</span><span class="p">,</span>
                        <span class="n">train_labels</span><span class="p">,</span>
                        <span class="n">test_data</span>
                        <span class="p">)</span>
</pre></div>
</div>
<p>As a note, it is suggested that all missing values are taken cared off before
using the model.</p>
</div>
<div class="section" id="documentation">
<h2>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h2>
<p>For code documentations, please go <a class="reference external" href="https://ed-turner.github.io/python-look-a-like/">here</a>.</p>
<p>Or have a look at the code <a class="reference external" href="https://github.com/ed-turner/look-a-like/tree/master/python-package">repository</a>.</p>
</div>
<div class="section" id="license">
<h2>License<a class="headerlink" href="#license" title="Permalink to this headline">¶</a></h2>
<p>This work is dual-licensed under Apache 2.0 and GPL 2.0 (or any later version).
You can choose between one of them if you use this work.</p>
<p><cite>SPDX-License-Identifier: Apache-2.0 OR GPL-2.0-or-later</cite></p>
</div>
</div>
<div class="section" id="lal">
<h1>lal<a class="headerlink" href="#lal" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-lal"></span><div class="section" id="lal-package">
<h2>lal package<a class="headerlink" href="#lal-package" title="Permalink to this headline">¶</a></h2>
<div class="section" id="subpackages">
<h3>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-lal.core"></span><div class="section" id="lal-core-package">
<h4>lal.core package<a class="headerlink" href="#lal-core-package" title="Permalink to this headline">¶</a></h4>
<div class="section" id="submodules">
<h5>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="module-lal.core.model">
<span id="lal-core-model-module"></span><h5>lal.core.model module<a class="headerlink" href="#module-lal.core.model" title="Permalink to this headline">¶</a></h5>
<dl class="class">
<dt id="lal.core.model.LALGBBaseModel">
<em class="property">class </em><code class="descclassname">lal.core.model.</code><code class="descname">LALGBBaseModel</code><span class="sig-paren">(</span><em>k</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.model.LALGBBaseModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This is a base model to help generate the Look-A-Like fitting structure.</p>
<p>Options for k is a non-negative integer, or linear_sum.
Options for p is a nonzero float, or cosine.</p>
<dl class="method">
<dt id="lal.core.model.LALGBBaseModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.model.LALGBBaseModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>We use the weighter object to generate our weights, all according to which type of machine-learning task
we are using.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>numpy.array</em>) – Our training data</p></li>
<li><p><strong>labels</strong> (<em>numpy.array</em>) – Our 1D training labels</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="lal.core.model.LALGBBaseModel.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>train_data</em>, <em>train_labels</em>, <em>test_data</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.model.LALGBBaseModel.predict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="lal.core.model.LALGBClassifier">
<em class="property">class </em><code class="descclassname">lal.core.model.</code><code class="descname">LALGBClassifier</code><span class="sig-paren">(</span><em>k</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.model.LALGBClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lal.core.model.LALGBBaseModel" title="lal.core.model.LALGBBaseModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">lal.core.model.LALGBBaseModel</span></code></a></p>
<p>This is when our training labels are categorical.</p>
<dl class="method">
<dt id="lal.core.model.LALGBClassifier.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>train_data</em>, <em>train_labels</em>, <em>test_data</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.model.LALGBClassifier.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>We choose most probable label our samples in the testing dataset has.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_data</strong> (<em>numpy.array</em>) – The training dataset features</p></li>
<li><p><strong>train_labels</strong> (<em>numpy.array</em>) – The training dataset labels</p></li>
<li><p><strong>test_data</strong> (<em>numpy.array</em>) – The testing dataset features</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="lal.core.model.LALGBClassifier.predict_proba">
<code class="descname">predict_proba</code><span class="sig-paren">(</span><em>train_data</em>, <em>train_labels</em>, <em>test_data</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.model.LALGBClassifier.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>This predicts the probability of our test data having any of the available labels in the training dataset</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_data</strong> (<em>numpy.array</em>) – The training dataset features</p></li>
<li><p><strong>train_labels</strong> (<em>numpy.array</em>) – The training dataset labels</p></li>
<li><p><strong>test_data</strong> (<em>numpy.array</em>) – The testing dataset features</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lal.core.model.LALGBRegressor">
<em class="property">class </em><code class="descclassname">lal.core.model.</code><code class="descname">LALGBRegressor</code><span class="sig-paren">(</span><em>k</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.model.LALGBRegressor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lal.core.model.LALGBBaseModel" title="lal.core.model.LALGBBaseModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">lal.core.model.LALGBBaseModel</span></code></a></p>
<p>This is when our training labels are continuous.</p>
<dl class="method">
<dt id="lal.core.model.LALGBRegressor.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>train_data</em>, <em>train_labels</em>, <em>test_data</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.model.LALGBRegressor.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>We predict the possible value our testing dataset will have, based on the continuous variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_data</strong> (<em>numpy.array</em>) – The training dataset features</p></li>
<li><p><strong>train_labels</strong> (<em>numpy.array</em>) – The training dataset labels</p></li>
<li><p><strong>test_data</strong> (<em>numpy.array</em>) – The testing dataset features</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-lal.core.nn">
<span id="lal-core-nn-module"></span><h5>lal.core.nn module<a class="headerlink" href="#module-lal.core.nn" title="Permalink to this headline">¶</a></h5>
<dl class="class">
<dt id="lal.core.nn.CosineDistanceBase">
<em class="property">class </em><code class="descclassname">lal.core.nn.</code><code class="descname">CosineDistanceBase</code><a class="headerlink" href="#lal.core.nn.CosineDistanceBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lal.core.nn.DistanceBase" title="lal.core.nn.DistanceBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">lal.core.nn.DistanceBase</span></code></a></p>
<p>This uses the cosine distance.</p>
<dl class="method">
<dt id="lal.core.nn.CosineDistanceBase.calc_dist">
<code class="descname">calc_dist</code><span class="sig-paren">(</span><em>mat1</em>, <em>mat2</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.nn.CosineDistanceBase.calc_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>This calculates the distance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mat1</strong> (<em>numpy.array</em>) – Sample 1</p></li>
<li><p><strong>mat2</strong> (<em>numpy.array</em>) – Sample 2</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lal.core.nn.DistanceBase">
<em class="property">class </em><code class="descclassname">lal.core.nn.</code><code class="descname">DistanceBase</code><a class="headerlink" href="#lal.core.nn.DistanceBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This is our base distance class.</p>
<dl class="method">
<dt id="lal.core.nn.DistanceBase.calc_dist">
<code class="descname">calc_dist</code><span class="sig-paren">(</span><em>mat1</em>, <em>mat2</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.nn.DistanceBase.calc_dist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="lal.core.nn.KNNBase">
<em class="property">class </em><code class="descclassname">lal.core.nn.</code><code class="descname">KNNBase</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.nn.KNNBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lal.core.nn.DistanceBase" title="lal.core.nn.DistanceBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">lal.core.nn.DistanceBase</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>This is another abstract class for our k-nearest neighbors algorithm</p>
<dl class="method">
<dt id="lal.core.nn.KNNBase.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>mat1</em>, <em>mat2</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.nn.KNNBase.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the memory-related issues with the algorithm.  We create a batch process and calculate the distances
on a batch of our samples, and generate our matches on that batch.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mat1</strong> (<em>numpy.array</em>) – Sample 1</p></li>
<li><p><strong>mat2</strong> (<em>numpy.array</em>) – Sample 2</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lal.core.nn.KNNCosineMatcher">
<em class="property">class </em><code class="descclassname">lal.core.nn.</code><code class="descname">KNNCosineMatcher</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.nn.KNNCosineMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lal.core.nn.CosineDistanceBase" title="lal.core.nn.CosineDistanceBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">lal.core.nn.CosineDistanceBase</span></code></a>, <a class="reference internal" href="#lal.core.nn.KNNBase" title="lal.core.nn.KNNBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">lal.core.nn.KNNBase</span></code></a></p>
<p>This is the K-Nearest Neighbor algorithm with the cosine distance measure.</p>
</dd></dl>

<dl class="class">
<dt id="lal.core.nn.KNNPowerMatcher">
<em class="property">class </em><code class="descclassname">lal.core.nn.</code><code class="descname">KNNPowerMatcher</code><span class="sig-paren">(</span><em>k</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.nn.KNNPowerMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lal.core.nn.PowerDistanceBase" title="lal.core.nn.PowerDistanceBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">lal.core.nn.PowerDistanceBase</span></code></a>, <a class="reference internal" href="#lal.core.nn.KNNBase" title="lal.core.nn.KNNBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">lal.core.nn.KNNBase</span></code></a></p>
<p>This is the K-Nearest Neighbor algorithm with the p-norm distance measure.</p>
</dd></dl>

<dl class="class">
<dt id="lal.core.nn.NNLinearSumBase">
<em class="property">class </em><code class="descclassname">lal.core.nn.</code><code class="descname">NNLinearSumBase</code><a class="headerlink" href="#lal.core.nn.NNLinearSumBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lal.core.nn.DistanceBase" title="lal.core.nn.DistanceBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">lal.core.nn.DistanceBase</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>This is the abstract class for the Hungarian Matching Algorithm, where we use the algorithm to exhaust all the
unique matches between our samples</p>
<dl class="method">
<dt id="lal.core.nn.NNLinearSumBase.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>mat1</em>, <em>mat2</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.nn.NNLinearSumBase.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all samples in mat2 to match to mat1 by using the linear_sum_assignment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mat1</strong> (<em>numpy.array</em>) – Sample 1</p></li>
<li><p><strong>mat2</strong> (<em>numpy.array</em>) – Sample 2</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lal.core.nn.NNLinearSumCosineMatcher">
<em class="property">class </em><code class="descclassname">lal.core.nn.</code><code class="descname">NNLinearSumCosineMatcher</code><a class="headerlink" href="#lal.core.nn.NNLinearSumCosineMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lal.core.nn.CosineDistanceBase" title="lal.core.nn.CosineDistanceBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">lal.core.nn.CosineDistanceBase</span></code></a>, <a class="reference internal" href="#lal.core.nn.NNLinearSumBase" title="lal.core.nn.NNLinearSumBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">lal.core.nn.NNLinearSumBase</span></code></a></p>
<p>This is the Exhaustive-Hungarian Matching algorithm with the cosine distance measure.</p>
</dd></dl>

<dl class="class">
<dt id="lal.core.nn.NNLinearSumPowerMatcher">
<em class="property">class </em><code class="descclassname">lal.core.nn.</code><code class="descname">NNLinearSumPowerMatcher</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.nn.NNLinearSumPowerMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lal.core.nn.PowerDistanceBase" title="lal.core.nn.PowerDistanceBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">lal.core.nn.PowerDistanceBase</span></code></a>, <a class="reference internal" href="#lal.core.nn.NNLinearSumBase" title="lal.core.nn.NNLinearSumBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">lal.core.nn.NNLinearSumBase</span></code></a></p>
<p>This is the Exhaustive-Hungarian Matching algorithm with the p-norm distance measure.</p>
</dd></dl>

<dl class="class">
<dt id="lal.core.nn.PowerDistanceBase">
<em class="property">class </em><code class="descclassname">lal.core.nn.</code><code class="descname">PowerDistanceBase</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.nn.PowerDistanceBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lal.core.nn.DistanceBase" title="lal.core.nn.DistanceBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">lal.core.nn.DistanceBase</span></code></a></p>
<p>This is the distance class that uses the p-norm to generate our distances.</p>
<dl class="method">
<dt id="lal.core.nn.PowerDistanceBase.calc_dist">
<code class="descname">calc_dist</code><span class="sig-paren">(</span><em>mat1</em>, <em>mat2</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.nn.PowerDistanceBase.calc_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>This calculates the distance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mat1</strong> (<em>numpy.array</em>) – Sample 1</p></li>
<li><p><strong>mat2</strong> (<em>numpy.array</em>) – Sample 2</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-lal.core.weights">
<span id="lal-core-weights-module"></span><h5>lal.core.weights module<a class="headerlink" href="#module-lal.core.weights" title="Permalink to this headline">¶</a></h5>
<dl class="class">
<dt id="lal.core.weights.LGBMClassifierWeight">
<em class="property">class </em><code class="descclassname">lal.core.weights.</code><code class="descname">LGBMClassifierWeight</code><a class="headerlink" href="#lal.core.weights.LGBMClassifierWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lal.core.weights.LGBMWeightsBase" title="lal.core.weights.LGBMWeightsBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">lal.core.weights.LGBMWeightsBase</span></code></a></p>
<p>This is for our classification-task</p>
</dd></dl>

<dl class="class">
<dt id="lal.core.weights.LGBMRegressorWeight">
<em class="property">class </em><code class="descclassname">lal.core.weights.</code><code class="descname">LGBMRegressorWeight</code><a class="headerlink" href="#lal.core.weights.LGBMRegressorWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lal.core.weights.LGBMWeightsBase" title="lal.core.weights.LGBMWeightsBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">lal.core.weights.LGBMWeightsBase</span></code></a></p>
<p>This is for our regression-task.</p>
</dd></dl>

<dl class="class">
<dt id="lal.core.weights.LGBMWeightsBase">
<em class="property">class </em><code class="descclassname">lal.core.weights.</code><code class="descname">LGBMWeightsBase</code><span class="sig-paren">(</span><em>metric_name</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.weights.LGBMWeightsBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This is our base class to help generate our importance weights for our features by using the feature_importance
from the gradient boosting method.</p>
<dl class="method">
<dt id="lal.core.weights.LGBMWeightsBase.get_feature_importances">
<code class="descname">get_feature_importances</code><span class="sig-paren">(</span><em>data</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#lal.core.weights.LGBMWeightsBase.get_feature_importances" title="Permalink to this definition">¶</a></dt>
<dd><p>After optimizing the model, we fit on the whole dataset, parse the feature_importance attribute and scale it
to sum to one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>numpy.array</em>) – Our training data</p></li>
<li><p><strong>labels</strong> (<em>numpy.array</em>) – Our 1D training labels</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-lal.core">
<span id="module-contents"></span><h5>Module contents<a class="headerlink" href="#module-lal.core" title="Permalink to this headline">¶</a></h5>
</div>
</div>
</div>
</div>
<div class="section" id="module-lal">
<span id="module-contents"></span><h3>Module contents<a class="headerlink" href="#module-lal" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; Copyright 2019, Edward Turner.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a>.
</div>
            </div>
          </div>
      </page>
  </div></body>
</html>